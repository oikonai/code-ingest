services:
  # Qdrant - Local vector database
  qdrant:
    image: qdrant/qdrant:latest
    container_name: code-ingest-qdrant
    ports:
      - "6333:6333"  # HTTP API
      - "6334:6334"  # gRPC API (optional)
    volumes:
      - qdrant-data:/qdrant/storage
    environment:
      - QDRANT__SERVICE__GRPC_PORT=6334
    networks:
      - code-ingest-network

  # Ingestion service - One-shot full re-ingestion (clone/refresh repos, discover, ingest, derive).
  # To skip re-ingestion and use existing data, start only qdrant and mcp: docker compose up qdrant mcp
  ingest:
    build:
      context: .
      dockerfile: Dockerfile.ingest
    container_name: code-ingest-ingestion
    depends_on:
      qdrant:
        condition: service_started
    environment:
      # Qdrant configuration
      # For local Docker: use http://qdrant:6333
      # For Qdrant Cloud: set QDRANT_URL and QDRANT_API_KEY in .env
      - QDRANT_URL=${QDRANT_URL:-http://qdrant:6333}
      - QDRANT_API_KEY=${QDRANT_API_KEY:-}
      
      # Embedding service (DeepInfra)
      - DEEPINFRA_API_KEY=${DEEPINFRA_API_KEY}
      - EMBEDDING_MODEL=${EMBEDDING_MODEL:-Qwen/Qwen3-Embedding-8B}
      # Chunks per embedding request (15 for standard model; use 25â€“100 if using -batch model)
      - BATCH_SIZE=${BATCH_SIZE:-15}
      # Request timeout in seconds (standard model can be slower)
      - EMBEDDING_TIMEOUT=${EMBEDDING_TIMEOUT:-120}
      
      # GitHub token for cloning
      - GITHUB_TOKEN=${GITHUB_TOKEN}
      
      # Optional: Priority filter (high=only high, medium=medium+high, low/ALL=all).
      # Default medium so repos without explicit priority in config get cloned.
      - PRIORITY=${PRIORITY:-low}
      
      # Logging level (DEBUG, INFO, WARNING, ERROR)
      - LOG_LEVEL=${LOG_LEVEL:-INFO}
    volumes:
      - ./repos:/app/repos  # Mount repos directory
      - ./config:/app/config  # Mount config
      - ingest-status:/app/status  # Shared volume for status file
    restart: "no"  # One-shot service
    networks:
      - code-ingest-network

  # MCP server - Query interface
  mcp:
    build:
      context: .
      dockerfile: Dockerfile.mcp
    container_name: code-ingest-mcp
    depends_on:
      qdrant:
        condition: service_started
    ports:
      - "8001:8001"  # MCP server port
    environment:
      # Qdrant configuration
      # For local Docker: use http://qdrant:6333
      # For Qdrant Cloud: set QDRANT_URL and QDRANT_API_KEY in .env
      - QDRANT_URL=${QDRANT_URL:-http://qdrant:6333}
      - QDRANT_API_KEY=${QDRANT_API_KEY:-}
      
      # Embedding service (DeepInfra)
      - DEEPINFRA_API_KEY=${DEEPINFRA_API_KEY}
      - EMBEDDING_MODEL=${EMBEDDING_MODEL:-Qwen/Qwen3-Embedding-8B}
      
      # Health endpoint and MCP over HTTP (Cursor connects to http://localhost:8001/mcp)
      - DOCKER_ENV=true
      - ENABLE_HEALTH_ENDPOINT=true
      - HEALTH_PORT=8001
      - MCP_HTTP_TRANSPORT=true
      
      # Logging level (DEBUG, INFO, WARNING, ERROR)
      - LOG_LEVEL=${LOG_LEVEL:-INFO}
    volumes:
      - ./config:/app/config  # Mount config
      - ingest-status:/app/status:ro  # Read-only access to status
    restart: unless-stopped
    networks:
      - code-ingest-network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8001/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s

volumes:
  qdrant-data:
    name: code-ingest-qdrant-data
  ingest-status:
    name: code-ingest-status

networks:
  code-ingest-network:
    name: code-ingest-network
    driver: bridge
